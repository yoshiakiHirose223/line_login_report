# 終業報告　2021/09/14
## 取り組んだ作業
- セキュリティ対策の方法と流れ、意義の再確認
  - PKCE,CSRF,OpenID Connectについて
- PKCEの実装
  - code_verifierの生成
  - code_challengeの生成
- 作業途中ですが再利用する定数についてファイルを分けたり、関数を役割ごとにファイルでまとめているところです。


## 学んだこと・気づいたこと
- PKCEの必要性
  - 仮に悪意あるウェブアプリやユーザーに認可・認証時のURLパラメーターやclient_idが盗み取られたとしても、第三者にアクセストークンが発行されてしまうというリスクを抑えることができる。
- CSRF
  - 認可・認証時のURLパラメーターにランダムな文字列をstateとして送信し、認可・認証後のコールバックにクエリパラメータとして同じstateが帰ってくる。
  - これを検証することでウェブアプリが受け取ったレスポンスがLINEログインボタン押下時のリクエストに対応するレスポンスであることを(100%ではないが)保証できる。
- OpenID Connect
  - 認証のためのプロトコル。受け取ったIDトークンが悪意あるウェブアプリやユーザーからのものであるかどうか、署名を確認することで判別できる。IDトークン検証用のエンドポイントがLINE APIに用意されている。
- Base64 encodeとBase64URL encode
  - 違いはクエリパラメータとして使えるかどうか。使えない文字の変換方法にはいくつかの規格がある（例：RFC 4648）

## 次回予定
- PKCEの実装がうまく進んでいないので、PKCEの実装を完了させる。
- IDトークンの検証処理の実装
- トークンの有効期限に応じて処理を分岐させる

##　質問
### PKCEの実装
PKCEの流れや実装の仕方はある程度わかったのですが、いざ実際にc`ode_verifier`の検証を行うとエラーが返ってきてしまいます。<br>
流れとしましては以下の通りです。<br>
- 認可・認証時のクエリパラメータに`code_verifier`を暗号化した`code_challenge`、暗号化の方法を指定した`code_challenge_method`を乗せる。
- この時に使用した`code_verifier`はセッションに保持
- その後アクセストークンのリクエスト時にメッセージボディに`code_verifier`を含める。
- LINE側が`code_verifier`を検証し、一致していたらアクセストークンを返す。

問題が発生している箇所は、LINE側の`code_verifier`検証に失敗しているようで、エラーレスポンスが返ってきます。<br>
`var_dump`でセッションに保持している`code_verifier`とメッセージボディに含める時の`code_verifier`を確認したのですがどちらも同じでした。<br>
他に実装方法に問題がないかなど見ていただけると幸いです。
[LINEログインをPKCE対応する](https://developers.line.biz/ja/docs/line-login/integrate-pkce/)